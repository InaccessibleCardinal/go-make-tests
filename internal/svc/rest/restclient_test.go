// imperfect test generated by openai
package rest

import (
	"bytes"
	"errors"
	"io"
	"net/http"
	"testing"
)

type mockRoundTripper struct {
	resp *http.Response
	err  error
}

func (m *mockRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	return m.resp, m.err
}

func TestRestClient_Do(t *testing.T) {
	t.Run("successful request", func(t *testing.T) {
		expectedBody := []byte("mock response body")
		expectedStatusCode := http.StatusOK
		expectedHeaders := map[string]string{"Content-Type": "application/json"}

		mockResp := &http.Response{
			Body:       io.NopCloser(bytes.NewBuffer(expectedBody)),
			StatusCode: expectedStatusCode,
			Header:     make(http.Header),
		}
		mockResp.Header.Add("Content-Type", "application/json")

		rc := &RestClient{
			client: &http.Client{Transport: &mockRoundTripper{resp: mockResp}},
		}
		res, err := rc.Get("http://example.com").Do()

		if err != nil {
			t.Errorf("unexpected error: %v", err)
		}

		if res.StatusCode != expectedStatusCode {
			t.Errorf("expected status code %d, got %d", expectedStatusCode, res.StatusCode)
		}

		if !bytes.Equal(res.Body, expectedBody) {
			t.Errorf("expected body %s, got %s", string(expectedBody), string(res.Body))
		}

		for key, value := range expectedHeaders {
			if res, ok := mockResp.Header[key]; !ok || len(res) == 0 || res[0] != value {
				t.Errorf("expected header %s: %s, got %v", key, value, res)
			}
		}
	})

	t.Run("error creating request", func(t *testing.T) {
		rc := &RestClient{}
		rc.err = errors.New("error creating request")
		_, err := rc.Get("http://example.com").Do()

		if err == nil {
			t.Error("expected an error but got nil")
		}
	})

	// t.Run("error performing request", func(t *testing.T) {
	// 	mockErr := errors.New("error performing request")
	// 	rc := &RestClient{
	// 		client: &http.Client{Transport: &mockRoundTripper{err: mockErr}},
	// 	}
	// 	_, err := rc.Url("http://example.com").Get().Do()

	// 	if err != mockErr {
	// 		t.Errorf("expected error %v, got %v", mockErr, err)
	// 	}
	// })
}
